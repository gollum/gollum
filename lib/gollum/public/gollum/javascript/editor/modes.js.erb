/*  modes.js

    Add highlighting rules for gollum-specific block level syntax to ACE.
    We first have to extends the Highlighters for each supported syntax,
    so that later, we can extend the relevant ACE Mode to use the custom Highlighter.
    We do this for all and only those languages which ACE supports, i.e.,
    for which it has a specific Highlighter and Mode. So we do not extend e.g. Creole,
    for which there is no ACE Mode (we use the 'text mode' instead).
    At the moment there are two gollum-wide block level syntaxes which need to be added:

    * GitHub style code blocks: ``` ... ```
    * UML blocks: @startuml ... @enduml

    The regexes defined for these below should be equivalent to the regexes used by
    gollum-lib to extract these blocks.

    ACE Docs:
      * Highlight Rules: https://cloud9-sdk.readme.io/docs/highlighting-rules
      * Dynamically generating modes: https://stackoverflow.com/questions/22166784/dynamically-update-syntax-highlighting-mode-rules-for-the-ace-editor
*/


<%
uml_rule_name = 'UMLBlock'
uml_rule_id = 'umlblock'
%>

// The rule defining the UML state for the ACE Tokenizer
var <%= uml_rule_name %>  = [{
  token: "support.function",
  regex: "^\\@enduml$",
  next:  "start"
  },
  {
    defaultToken: "support.function"
  }];

// The rule defining how the ACE Tokenizer gets into the UML state
var UMLStart = {
  token: "support.function",
  regex: "^(?:[ \\t]*)\\@startuml$",
  next:  "<%= uml_rule_id %>"
};

<%
codeblock_rule_name = 'GithubCodeBlock'
codeblock_rule_id = 'githubblock';
%>

// Generic rule for github style fenced code blocks (both for three backticks, or tildes).
// The generic approach was lifted from ACE's markdown_highlight_rules.js
// Relies on startCodeBlockMatch to be called in the 'start' state to log the length and kind of the opening tag.
var <%= codeblock_rule_name %> = [{
  token: "support.function",
  regex: ".*",
  onMatch:  function(value, state, stack, line) {
              var length     = stack[2][0];
              var symbol     = stack[2][1];
              // length and symbol are logged by startCodeBlockMatch
              var match = /^( {0,3})(~~[~]+|```)\s*$/.exec(value);
              // if there's a matching close tag, it's at least as long as the logged open tag, and it's the same character (backtick or tilde) as the opening tag.
              if (match && match[2].length >= length && match[2].charAt(0) == symbol) {
                stack.splice(0, 3);
                this.next = stack.shift();
                return this.token;
              }
              this.next = "";
              return this.token;
            }
  },
  {
    defaultToken: "support.function"
  }];

// When we have a match for the start of a code block, log the information how long the opening tag was, and which character (backtick or tilde) it used.
var startCodeBlockMatch = function(value, state, stack, line) {
  var match = new RegExp(this.regex).exec(value);
  stack.unshift("<%= codeblock_rule_id %>", [], [match[2].length, match[2].charAt(0)], state);
  return this.token;
}

// Three backticks should work on all pages
var GollumCodeStart = {
  token: "support.function",
  regex: "^( {0,3})(```)[^`]*$",
  onMatch: startCodeBlockMatch,
  next:  "<%= codeblock_rule_id %>"
};

// Markdown pages should also support fenced code blocks
var MarkdownCodeStart = {
  token: "support.function",
  regex: "^( {0,3})(~~[~]+)[^`~]*$",
  onMatch: startCodeBlockMatch,
  next:  "<%= codeblock_rule_id %>"
};

<%
default_rules = {
  :path => '',
  :rule_name => '',
  :start_rules => ['GollumCodeStart', 'UMLStart'],
  :block_rules => {codeblock_rule_id => codeblock_rule_name, uml_rule_id => uml_rule_name}
}

rst_rules = default_rules.dup
rst_rules[:path] = 'ace/mode/rst_highlight_rules'
rst_rules[:rule_name] = 'RSTHighlightRules'

asciidoc_rules = default_rules.dup
asciidoc_rules[:path] = 'ace/mode/asciidoc_highlight_rules'
asciidoc_rules[:rule_name] = 'AsciidocHighlightRules'

textile_rules = default_rules.dup
textile_rules[:path] = 'ace/mode/textile_highlight_rules'
textile_rules[:rule_name] = 'TextileHighlightRules'

markdown_rules = default_rules.dup
markdown_rules[:path] = 'ace/mode/markdown_highlight_rules'
markdown_rules[:rule_name] = 'MarkdownHighlightRules'
markdown_rules[:start_rules] = ['GollumCodeStart', 'UMLStart', 'MarkdownCodeStart'] # Markdown pages should also support fenced code blocks


{
  'GollumRstHighlightRules'      => rst_rules,
  'GollumAsciidocHighlightRules' => asciidoc_rules,
  'GollumTextileHighlightRules'  => textile_rules,
  'GollumMarkdownHighlightRules' => markdown_rules 
}.each do |name, highlighter|
%>
// Register gollum-specific HighlightRules with ACE
ace.define("<%= name %>", [], function(require, exports, module) {
  "use strict";

  var oop = require("ace/lib/oop");
  var BaseHighlightRules = require('<%= highlighter[:path] %>').<%= highlighter[:rule_name] %>;

  var GollumHighlightRules = function() {
    var mergeRules = new BaseHighlightRules();
    this.$rules = mergeRules.getRules();
    this.$rules.start = this.$rules.start.filter(function (item) {
      return !(item.next == 'githubblock');
    });
    <% highlighter[:start_rules].each do |rule| %>
    this.$rules.start.unshift(<%= rule %>);
    <% end %>
    <% highlighter[:block_rules].each do |id, rule| %>
    this.addRules({
      <%= id %> : <%= rule %>
    });
    <% end %>
    this.normalizeRules();
  };

  oop.inherits(GollumHighlightRules, BaseHighlightRules);

  exports.GollumHighlightRules = GollumHighlightRules;
});
<% end %>
// Done defining the extended HighlightRule definitions

(function($) {
  var AceMode = {
    asciidoc: 'GollumAsciidocHighlightRules',
    creole: 'text',
    markdown: 'GollumMarkdownHighlightRules',
    mediawiki: 'text',
    bib: 'latex',
    org: 'text',
    rst: 'GollumRstHighlightRules',
    txt: 'text',
    pod: 'text',
    rdoc: 'rdoc',
    textile: 'GollumTextileHighlightRules'
  };

  $.getEditorMode = function ( mode ) {
    var ace_mode = '';
    if (ace_mode = AceMode[mode]) {
      if (ace_mode.startsWith('Gollum')){ // We have extended highlighters
        var baseMode = ace.require("ace/mode/" + mode).Mode;
        var dynamicMode = new baseMode();
        dynamicMode.HighlightRules = ace.require(ace_mode).GollumHighlightRules;
        return dynamicMode;      
      } else {
        return "ace/mode/" + ace_mode;
      }
    } else {
      return null;
    }
  }

})(jQuery);